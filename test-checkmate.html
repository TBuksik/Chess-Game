<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Checkmate Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-board {
            display: grid;
            grid-template-columns: repeat(8, 30px);
            grid-template-rows: repeat(8, 30px);
            gap: 1px;
            background: #333;
            margin: 10px 0;
        }
        .test-square {
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        .test-square.dark {
            background: #888;
        }
    </style>
</head>
<body>
    <h1>Chess Checkmate Detection Test</h1>
    <div id="test-results"></div>
    
    <script>
        // Mock chess classes for testing
        class MockChessPiece {
            constructor(type, color, row, col) {
                this.type = type;
                this.color = color;
                this.row = row;
                this.col = col;
                this.hasMoved = false;
                this.moveCount = 0;
            }
            
            clone() {
                const piece = new MockChessPiece(this.type, this.color, this.row, this.col);
                piece.hasMoved = this.hasMoved;
                piece.moveCount = this.moveCount;
                return piece;
            }
            
            moveTo(row, col) {
                this.row = row;
                this.col = col;
                this.hasMoved = true;
                this.moveCount++;
            }
            
            getValidMoves(board) {
                // Simplified move generation for testing
                const moves = [];
                const directions = {
                    'king': [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]],
                    'queen': [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]],
                    'rook': [[-1,0],[1,0],[0,-1],[0,1]]
                };
                
                if (this.type === 'king') {
                    for (let [rowOffset, colOffset] of directions.king) {
                        const newRow = this.row + rowOffset;
                        const newCol = this.col + colOffset;
                        if (isValidSquare(newRow, newCol)) {
                            const target = board[newRow][newCol];
                            if (!target || target.color !== this.color) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    }
                } else if (this.type === 'queen' || this.type === 'rook') {
                    const moveDirections = this.type === 'queen' ? directions.queen : directions.rook;
                    for (let [rowDir, colDir] of moveDirections) {
                        for (let i = 1; i < 8; i++) {
                            const newRow = this.row + rowDir * i;
                            const newCol = this.col + colDir * i;
                            if (!isValidSquare(newRow, newCol)) break;
                            
                            const target = board[newRow][newCol];
                            if (!target) {
                                moves.push([newRow, newCol]);
                            } else {
                                if (target.color !== this.color) {
                                    moves.push([newRow, newCol]);
                                }
                                break;
                            }
                        }
                    }
                }
                
                return moves;
            }
        }
        
        function isValidSquare(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }
        
        function getOppositeColor(color) {
            return color === 'white' ? 'black' : 'white';
        }
        
        // Mock MoveValidator
        class MockMoveValidator {
            static findKing(board, color) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.type === 'king' && piece.color === color) {
                            return piece;
                        }
                    }
                }
                return null;
            }
            
            static isKingInCheck(board, color) {
                const king = this.findKing(board, color);
                if (!king) return false;
                
                const oppositeColor = getOppositeColor(color);
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === oppositeColor) {
                            const moves = piece.getValidMoves(board);
                            if (moves.some(([r, c]) => r === king.row && c === king.col)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            static simulateMove(board, fromRow, fromCol, toRow, toCol) {
                const newBoard = board.map(row => row.map(piece => piece ? piece.clone() : null));
                const piece = newBoard[fromRow][fromCol];
                
                if (piece) {
                    newBoard[toRow][toCol] = piece;
                    newBoard[fromRow][fromCol] = null;
                    piece.row = toRow;
                    piece.col = toCol;
                }
                
                return newBoard;
            }
            
            static isValidMove(piece, toRow, toCol, board, gameState) {
                if (!isValidSquare(toRow, toCol)) return false;
                
                const target = board[toRow][toCol];
                if (target && target.color === piece.color) return false;
                
                const validMoves = piece.getValidMoves(board);
                const moveExists = validMoves.some(([r, c]) => r === toRow && c === toCol);
                
                if (!moveExists) return false;
                
                // Check if move would put own king in check
                const testBoard = this.simulateMove(board, piece.row, piece.col, toRow, toCol);
                if (this.isKingInCheck(testBoard, piece.color)) {
                    return false;
                }
                
                return true;
            }
            
            static isCheckmate(board, color) {
                if (!this.isKingInCheck(board, color)) {
                    console.log('Not in check, so not checkmate');
                    return false;
                }
                
                // Check if any move can get out of check
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color === color) {
                            const moves = piece.getValidMoves(board);
                            console.log(`Checking piece ${piece.type} at (${row},${col}), moves:`, moves);
                            for (let [toRow, toCol] of moves) {
                                // Simulate the move and check if king is still in check
                                const testBoard = this.simulateMove(board, row, col, toRow, toCol);
                                if (!this.isKingInCheck(testBoard, color)) {
                                    console.log(`Found valid escape move: ${piece.type} from (${row},${col}) to (${toRow},${toCol})`);
                                    return false; // Found a move that gets out of check
                                }
                            }
                        }
                    }
                }
                
                console.log('Checkmate result: true (no escape moves found)');
                return true; // No moves can get out of check, it's checkmate
            }
        }
        
        // Test functions
        function runTests() {
            const resultsDiv = document.getElementById('test-results');
            
            // Test 1: Proper checkmate scenario
            function testBasicCheckmate() {
                console.log('=== TESTING BASIC CHECKMATE ===');
                
                // Create a very simple checkmate position
                const board = Array(8).fill().map(() => Array(8).fill(null));
                
                // Set up a simple mate: Black king in corner, white queen and king
                board[0][0] = new MockChessPiece('king', 'black', 0, 0);     // Black king on a8
                board[1][1] = new MockChessPiece('queen', 'white', 1, 1);   // White queen on b7
                board[2][1] = new MockChessPiece('king', 'white', 2, 1);    // White king on b6
                
                console.log('Board setup:');
                console.log('- Black king at (0,0) - a8');
                console.log('- White queen at (1,1) - b7');
                console.log('- White king at (2,1) - b6');
                
                // Check if black king is in check
                const isInCheck = MockMoveValidator.isKingInCheck(board, 'black');
                console.log('Is black king in check?', isInCheck);
                
                // Check if it's checkmate
                const isCheckmate = MockMoveValidator.isCheckmate(board, 'black');
                console.log('Is it checkmate?', isCheckmate);
                
                // Debug king moves
                const blackKing = board[0][0];
                const kingMoves = blackKing.getValidMoves(board);
                console.log('Black king possible moves:', kingMoves);
                
                // Check each move
                for (let [toRow, toCol] of kingMoves) {
                    const testBoard = MockMoveValidator.simulateMove(board, 0, 0, toRow, toCol);
                    const stillInCheck = MockMoveValidator.isKingInCheck(testBoard, 'black');
                    console.log(`King move to (${toRow},${toCol}): still in check = ${stillInCheck}`);
                }
                
                console.log('=== END BASIC CHECKMATE TEST ===');
                return isInCheck && isCheckmate;
            }
            
            // Test 2: Not checkmate (king can move)
            function testNotCheckmate() {
                const board = Array(8).fill().map(() => Array(8).fill(null));
                
                // Place pieces where king is in check but can escape
                board[0][4] = new MockChessPiece('king', 'black', 0, 4);     // Black king on e8
                board[1][3] = new MockChessPiece('queen', 'white', 1, 3);   // White queen on d7 (giving check)
                board[7][4] = new MockChessPiece('king', 'white', 7, 4);    // White king on e1
                
                // King should be in check but not checkmate (can move to d8, f8, etc.)
                const isInCheck = MockMoveValidator.isKingInCheck(board, 'black');
                const isCheckmate = MockMoveValidator.isCheckmate(board, 'black');
                
                console.log('Not checkmate test:', { isInCheck, isCheckmate });
                console.log('Black king should be in check but have escape squares');
                
                // Test king moves manually
                const kingMoves = board[0][4].getValidMoves(board);
                console.log('Black king possible moves:', kingMoves);
                
                let safeMovesCount = 0;
                for (let [toRow, toCol] of kingMoves) {
                    const testBoard = MockMoveValidator.simulateMove(board, 0, 4, toRow, toCol);
                    const stillInCheck = MockMoveValidator.isKingInCheck(testBoard, 'black');
                    console.log(`King move to (${toRow},${toCol}): still in check = ${stillInCheck}`);
                    if (!stillInCheck) safeMovesCount++;
                }
                
                console.log(`Safe moves available: ${safeMovesCount}`);
                
                return isInCheck && !isCheckmate && safeMovesCount > 0;
            }
            
            // Test 3: Game state handling
            function testGameStateHandling() {
                const mockGame = {
                    gameState: 'playing',
                    currentPlayer: 'white',
                    
                    checkGameState: function() {
                        // Simulate checkmate detection
                        if (this.gameState === 'playing') {
                            this.gameState = 'checkmate';
                            this.endGame('checkmate');
                        }
                    },
                    
                    endGame: function(reason) {
                        this.gameState = reason;
                    },
                    
                    canMakeMove: function() {
                        return this.gameState === 'playing';
                    }
                };
                
                // Initially should be able to make moves
                const canMoveInitially = mockGame.canMakeMove();
                
                // After checkmate, should not be able to make moves
                mockGame.checkGameState();
                const canMoveAfterCheckmate = mockGame.canMakeMove();
                
                return canMoveInitially && !canMoveAfterCheckmate && mockGame.gameState === 'checkmate';
            }
            
            // Run tests
            const tests = [
                { name: 'Basic checkmate detection', fn: testBasicCheckmate },
                { name: 'Not checkmate (king can escape)', fn: testNotCheckmate },
                { name: 'Game state handling after checkmate', fn: testGameStateHandling }
            ];
            
            tests.forEach(test => {
                const result = test.fn();
                const div = document.createElement('div');
                div.className = `test-result ${result ? 'pass' : 'fail'}`;
                div.textContent = `${test.name}: ${result ? 'PASS' : 'FAIL'}`;
                resultsDiv.appendChild(div);
            });
            
            // Overall result
            const allPassed = tests.every(test => test.fn());
            const overallDiv = document.createElement('div');
            overallDiv.className = `test-result ${allPassed ? 'pass' : 'fail'}`;
            overallDiv.innerHTML = `<strong>Checkmate Detection: ${allPassed ? 'WORKING CORRECTLY' : 'NEEDS FIXES'}</strong>`;
            resultsDiv.appendChild(overallDiv);
        }
        
        // Run tests when page loads
        window.onload = runTests;
    </script>
</body>
</html>
